#include "set.hpp"

// Default constructor
// Creating an empty set with one dummy node
Set::Set() : head{ new Node(0, nullptr) }
{  
}


// Constructor for creating a set from an int
// Creating a set with one node from the "insert function"
Set::Set(int v) : Set()
{
	insert(head, v);
}

// Insert function
// Creates a node with a value and a pointer next as arg.
void Set::insert(Node* p, int value) const
{
	Node* newNode = new Node(value, p->next);
	p->next = newNode;
}

// Sorting for the insert of the node
void Set::insert(int value) const
{
	Node* p = head;

	while ((p->next != nullptr) && (p->next->value < value))  
	{
		p = p->next;
	}

	if (p->next == nullptr || p->next->value != value) {

		insert(p, value);
	}
}

// Removes a node
void Set::remove(Node* p)
{
	delete p;
}


// Constructor that creates a set from an array and an int, non-sorted
Set::Set(const int a[], int n) : Set()
{
	for (int i = 0; i < n; i++) {
		insert(a[i]);
	}
}

// Copy constructor generated by the compiler
Set::Set(const Set& S) : Set() // Default constructor
{
	Node* p = S.head->next;
	Node* p2 = head;

	while (p != nullptr) { // As long as set S has values, then insert each value from p with a pointer p2 in the empty set.
		insert(p2, p->value);
		p = p->next;
		p2 = p2->next;
	}

}

// Destructor: deallocate all nodes
Set::~Set() 
{
	Node* p = head;
	Node* temp;

	while (p != nullptr) { // Deletes every node starting from the dummy
		temp = p->next;
		remove(p);
		p = temp;
	}
} 


// Tests if the set is empty
bool Set::empty() const 
{
	Node* p = head->next;

	return (p == nullptr);
}

// Returns number of elements in the set
int Set::cardinality() const
{
	Node *p = head->next;
	int howMany = 0;         
	while (p != nullptr) {
		p = p->next;
		howMany ++;            //Increases the number of elements, starting with 0
	}
	return howMany;
}

// Tests if x is an element of the set
bool Set::member(int x) const 
{
	Node* p = head->next;

	while ((p != nullptr) && (p->value != x))  //As long as p is not a nullptr and does not have the same value as x, check the next one
	{
		p = p->next;
	}

	if (p == nullptr) {
		return false;  
	}
	else {

		return true;
	}
}

// Assignment operator
Set& Set::operator=(Set s)
{
	//LHS "head" gets swaped to point to temp.head
	std::swap(head, s.head);

	return *this; 
}

//Returns true if b is a subset, otherwise false i returned.
bool Set::operator<=(const Set& b) const 
{
	Node* p = head->next;

	while (p != nullptr) {
		if (!b.member(p->value)) { // b is a subset only if every member of b is a number of the set ??? Kollar vi inte efter om alla p-value finns i b?
			return false;
		}

		p = p->next;
	}

	return true;
}

// Returns true if b is a subset of p and p is a subset of b. 
bool Set::operator==(const Set& b) const
{
	return (*this <= b && b <= *this);
}
// Returns true if b is not not a subset of p and vice versa
bool Set::operator!=(const Set& b) const
{

	return (!(*this == b));
}
// Returns true if b is a proper subset of p, p must have other elements than the subset-values
bool Set::operator<(const Set& b) const 
{
	
	if (*this <= b)
	{
		if (*this == b) {
			return false;
		}

		else {
			return true;
		}
	}

	return false;
}

// Set union
// Repeated values are not allowed
Set Set::operator+(const Set& b) const 
{
	Set mergedSet;

	Node* p_b = b.head->next;
	Node* p_this = head->next;

	while (p_b != nullptr) { //As long as there is elements in p_b, insert all

		mergedSet.insert(p_b->value); // Sorting happens in insert()
		p_b = p_b->next;
	}

	while (p_this != nullptr) { //As long as there is elements in p_this, insert all

		mergedSet.insert(p_this->value);
		p_this = p_this->next;
	}

	return mergedSet;
}

// Set intersection, creates a new set with the common values of this and b
Set Set::operator*(const Set& b) const 
{
	Set mergedSet;

	Node* p = head->next;

	while ((p != nullptr)) {

		if ((b.member(p->value))) { // Check if p->value is a member of set b, then insert the element in mergedSet
			mergedSet.insert(p->value);
		}

		p = p->next;
	}

    return mergedSet;
}

// Set difference, creates a new set with the "single" elements of this and b
Set Set::operator-(const Set& b) const 
{
	Set mergedSet;

	Node* p = head->next;

	while ((p != nullptr)) {

		if ((!b.member(p->value))) { // Check if p->value is NOT a member of set b, then insert the element in mergedSet
			mergedSet.insert(p->value);
		}

		p = p->next;
	}

	return mergedSet;  // to be deleted
}

// Set union with set {x}
// Create a set of int x then use the "+" operator function
Set Set::operator+(int x) const 
{
	Set s(x);
	return *this+s; //I en operator funktion befinner man sig i VL, och *this pekar då på "där vi befinner oss"
}

// Set difference with set {x}
// Create a set of int x then use the "-" operator function
Set Set::operator-(int x) const 
{
	Set s(x);
	return *this - s;
}

std::ostream& operator<<(std::ostream& os, const Set& theSet) 
{
	if (theSet.empty())
	{
		os << "Set is empty!";
	}
    else
	{
        Set::Node* temp = theSet.head->next;
        os << "{ ";

        while (temp)
		{
            os << temp->value << " ";
            temp = temp->next;
        }
        os << "}";
    }

    return os;
}



